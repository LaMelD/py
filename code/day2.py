# day 2

# 튜플
## 튜플은 리스트와 비슷하다
## 리스트와의 차이점으로 리스트는 생성, 삭제, 수정이 가능한 반면
## 튜플은 불가능하다.
# 선언
tup = ()
tup = (1, )
tup = (1, 2, 3)
tup = 1, 2, 3

# tuple(튜플)은 read only로 되어 있다.
# 최초 1회 설정되면 이후에 값을 바꿀 수 없고 새로운 튜플을 생성하여 변수에 넣어주어야 한다.

tup1 = (1, 2, 3)
tup2 = (4, 5, 6)

res = tup1[1] # 인데스 접근
res = tup1[:2] # 슬라이싱
res = tup1 + tup2 # 튜플 더하기
res = tup1 * 3 # 튜플 곱하기

# ======================================================================================

# 딕셔너리

# key, value 쌍으로 구성된다.
## 연관 배열(Associate Array) 또는 해시(Hash) 자료형이다.
## 순차적으로 정리되어 있지 않다.--> Not Sequential
# 선언
dic = {'key1':'value1', 'key2':'value2', 'key3':'value3', 'key4':'value4'}

# key, value 쌍 추가
dic = {2:'a'}
dic[1] = 'b'
dic['name'] = 'Lee'
dic['li'] = [1, 2, 3]

# 제거
del dic['name'] # 'name'을 키로하는 쌍을 제거한다.

# Key 관련 내용
## key는 고유한 것이다!!
### 중복이 있다면 가장 앞쪽에 있는 것을 인식하고 나머지는 쓰레기가 된다.
## key는 변하지 않는 값이여야 한다!!
### List나 Dictionary와 같이 변하는 값은 Key로 사용이 불가능 하다.
### 튜플은 변하지 않는 값이기 때문에 Key로 사용이 가능하다.

# 관련 함수
dic = {2:'a', 1:'b', 'name':'Lee', 'li':[1, 2, 3]}
## Key 리스트 만들기
### 키 값만 모아둔다.(dict_keys 객체를 리턴)
dic.keys()
### 2.7버전까지는 list를 리턴했다. 이후 버전에서 list로 사용하면 아래와 같이 해야한다.
list(dic.keys())
### dict_keys 객체 : 리스트와 비슷하지만 append, insert, pop, remove, sort 등의 함수는 사용이 불가능하다.

## Value 리스트 만들기
### Value 값만 모아둔다.(dict_values 객체를 리턴)
dic.values()
### Key 리스트의 내용과 동일하다.
list(dic.values())

## Key, Value 쌍 얻기
### 쌍을 얻어온다. 결과로 dict_items 객체를 돌려준다.
dic.items()
### list로 변환하여 받는다면
print(list(dic.items()))
### [(2, 'a'), (1, 'b'), ('name', 'Lee'), ('li', [1, 2, 3])] 결과가 출력된다.
### 리스트 안에 각각의 쌍이 튜플 형태로 나와있는 것을 확인할 수 있다.

## 모두 지우기 :: 모든 Key, Value 쌍을 제거한다.
dic.clear()

dic = {2:'a', 1:'b', 'name':'Lee', 'li':[1, 2, 3]}
## Key로 Value 값 얻기
### dic.get(Key값) --> 리턴값으로 value값을 가져온다.
### dic[Key값]과 같은 결과가 나온다.
### 차이점 :: 존재하지 않는 key값을 찾을 때 get은 None을 리턴하고 dic[key값]은 오류를 발생시킨다.
### dic.get(Key값, 디폴트)를 사용해 찾으려는 Key가 존재하지 않는다면 디폴트를 리턴하게 할 수 있다.
dic.get('name')
dic['name']
dic.get('email')
# dic['email'] # 오류발생!!
dic.get('name', '해당 키값 없음')
dic.get('email', '해당 키값 없음')

## 해당 Key가 dictionary에 있는지 확인
### 리턴으로 True, False (참/거짓)을 리턴한다.
print('name' in dic)
print('email' in dic)

# =============================================================================================

# 집합

# 선언
s1 = set([1, 2, 3])
# 특징
## 중복을 허용하지 않는다.
## 순서가 없다 <----> 리스트 튜플은 순서가 있다.
### 따라서 인덱싱으로 값을 얻을 수 없다.
### 인덱싱으로 값을 얻기 위해서는 list로 변환하여 인덱싱으로 값을 얻어야 한다.
l1 = list(s1)
print("변환후 인덱싱으로 값을 얻는다 : " + str(l1[1]))

# 활용 :: 다이어그램을 참고하는 것을 추천한다.
a = set([1, 2, 3])
b = set([2, 3, 4])
## 교집합
inter = a & b
inter = a.intersection(b)
## 합집합
uni = a | b
uni = a.union(b)
## 여집합
left = a - b
left = a.difference(b)
right = b - a
right = b.difference(a)

# 관련 함수
s1 = set([1, 2, 3])
s1.add(4) ## 1개의 값 추가
s1.update([5, 6, 7]) ## 여러개의 값 추가
s1.remove(3) ## 특정 값 제거

# =============================================================================================

# 자료형의 참/거짓

# 문자열
## 참 : "빈 문자열이 아니라면 참"
## 거짓 : "" 문자열이 비어있다면 거짓
# 리스트
## 참 : ["비어있는 리스트가 아니라면 참", 1, 2]
## 거짓 : [] 리스트가 비어있다면 거짓
# 튜플
## 참 : ("비어있는 튜플이 아니라면 참", 1, 2, 3)
## 거짓 : () 튜플이 비어있다면 거짓
# 딕셔너리
## 참 : {"비어있는 딕션이 아니라면":"참", 1:"a"}
## 거짓 : {} 딕션이 비어있다면 거짓
# 숫자형
## 참 : 0이 아닌 숫자
## 거짓 : 0
# NONE : 거짓

# =============================================================================================

# 변수

# 변수(Variable) in python :: 객체를 가르키는 것
## 파이썬에서는 자료형을 따로 쓸 필요가 없다. 알아서 판단한다.
# 객체(Object) in python :: 파이썬에서 사용되는 모든 것
## 모든 것은 객체이다...(숫자 : 정수형 객체)
a = 3
b = 3 # a도 3 이라는 정수형 객체를 가리키고, b 도 3 이라는 정수형 객체를 가리킨다.
print(a is b) # a 와 b가 같은 객체를 가리키고 있는가? YES :: True
# 메모리에 생성된 변수 제거
## 위와 같이 변수를 선언 했다면 변수는 메모리 상에 올라가게 된다.
## 프로그램이 종료되면 메모리에서 제거되지만 수동으로 제거도 가능하다.
del(a)
del(b) # del(변수명)
# 리스트의 복사
a = [1, 2, 3]
b = a
print(a is b)
## a와 b가 같은 객체를 가리키고 있다.
## 이를 해결하기 위해서 a 리스트 전체를 복사하여 b에 넣어준다.
a = [1, 2, 3]
b = a[:]
print(a is b)
## copy를 이용하는 방법
from copy import copy
a = [1, 2, 3]
b = copy(a)
print(a is b)
a = {1:'a', 2:'b'}
b = copy(a)
print("딕션도 적용? " + str(a is b)) # 딕션도 적용이 된다.
a = (1, 2, 3)
b = copy(a)
print("튜플도 적용? " + str(a is b)) # 튜플은 적용이 안된다. 같은 객체를 가리키고 있다. 변하지 않아서 그런 것 같다.
a = set([1, 2, 3])
b = copy(a)
print("집합도 적용? " + str(a is b)) # 집합도 적용이 된다.

# =============================================================================================